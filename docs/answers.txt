a)  Enumerating objects: 12, done.
	Counting objects: 100% (12/12), done.
	Delta compression using up to 4 threads
	Compressing objects: 100% (8/8), done.
	Writing objects: 100% (10/10), 1.00 KiB | 513.00 KiB/s, done.
	Total 10 (delta 3), reused 0 (delta 0)
	remote: Resolving deltas: 100% (3/3), completed with 1 local object.
	To https://github.com/jds17e/assignment2.git
	   f4975e5..b080a8a  master -> master

b)  9 commits
	command: git rev-list --all --count

c)  Wednesday September 25th, 2019
	command: git log .gitignore

d)  Branches allow for multiple team members to safely work on a project without messing up someone else's work. Since everyone can have their own branch, no one will overwrite someone’s work since you must merge first and check for issues. Another reason for using branches is that you can work on new features for your software without messing up any of the existing features. So, if you want to add a new screen to your app, you can do so safely without changing the main app. This allows you to check with a client if they like the change or not while also fixing bugs on the main branch. 

e)	Git status shows the status of the current tree you are working in. It shows which files have been added along with files that have modified. Git log is more focused on the actual commits to the branch and shows more information on each commit. If you were looking for commit messages, for example, you would use git log instead of git status. But if you aren’t sure what files you have modified, git status would be the command you want to run.

f) git log --follow Vehicle.h

g) git log --grep="file"

h)  Inheritance is when a sub class is given the same attributes as a parent class. A pigeon class that 		inherits from a bird class could inherit an Boolean variable named canFly for example. 

	Polymorphism has two forms: runtime and compile time. Runtime polymorphism is when a derived class has a definition for a member function of the base class. Compile time polymorphism can be achieved by having multiple functions with the same name but different parameters. The behavior of the function depends on the parameters given even though they all have the same name. This type of polymorphism can also be achieved by operator overloading. 

	Encapsulation is the process in which data is stored privately in a class with public member functions to retrieve it. By making the data a private attribute of a class, it cannot be accessed directly and thus adds an extra layer of security. The only way to retrieve this data is with a public member function such as getValue().


i) In a "Dictator and Lieutenants" workflow, the developers push their work to a Lieutenants repository where she has to make sure they merge properly. The Lieutenants are in charge of multiple developers but not all of them. The Dictator then takes all the Lieutenants work and merges it in their repository. Once everything is resolved, it is pushed the central repository. In an integration management workflow, developers work in a private repository and push to a public copy of their repository. The integration manager then pulls from the public repositories and merges all the changes before pushing to the central repository. Integration managers act as a Dictator and a Lieutenant at the same time. 

j) When 100 developers are working on a project, it makes more sense to have a Dictator and Lieutenant flow because this allows for more checks before pushing to the central repository. If there is an issue between two developers code, it will be caught by a lieutenant before making its way to the central repository. And if the lieutenants have conflicting code, the dictator will catch it before it is pushed to the central repository. Working with a centralized flow would lack these systematic checks and with 100 developers, it can be difficult to make sure you are all on the same page. There will certainly be code conflicts and it makes more sense to take care of these before pushing to the central branch, not after.  


5) The Driving Simulator prototype is using polymorphism and encapsulation together. While we do not use compile time polymorphism, we are using runtime polymorphism. An example of this would be the mileageEstimate function because this function is inherited but each class tweaks the definition to calculate mileage for the specific vehicle. The function toString is also inherited but changed in each derived class to output any vehicle specific data. Encapsulation occurs in most of the classes as well because we set private member data but only interact with it using public get and set functions. The private data is never changed directly.
